#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
overlay_roles_to_mermaid.py (v4: label-first matching)
- 役割パターンを「ノードID」だけでなく「ラベル（[...]の中身）」に優先してマッチ
- パスっぽいパターン（"src/plan_data/collector.py" 等）は basename に自動変換してラベルへ照合
- さらにフォールバックとして ID を“擬似パス復元”して緩く照合（__ → /, _ → [-_])
- 既存の manifest/spine もそのまま利用可
"""

from __future__ import annotations
import argparse
import fnmatch
import json
import re
from pathlib import Path
from typing import Dict, List, Set

import yaml  # pip install PyYAML

NODE_RE = re.compile(r"^\s*([A-Za-z0-9_./:\-]+)\s*\[(.*?)\]\s*(?::[:A-Za-z0-9 _-]+)?$")


def parse_nodes(lines: List[str]) -> Dict[str, str]:
    """nodeId[Label] を dict へ"""
    nodes: Dict[str, str] = {}
    for ln in lines:
        m = NODE_RE.match(ln)
        if m:
            nid = m.group(1).strip()
            label = m.group(2).strip()
            nodes[nid] = label
    return nodes


def _basename(glob: str) -> str:
    """パスっぽいパターンから最後のセグメント（basename の glob）を取る"""
    if "/" in glob:
        return glob.split("/")[-1]
    return glob


def _label_globs_from_pattern(pat: str) -> List[str]:
    """
    roles.yml のパターン 1 個から、ラベル照合用の glob 群を作る。
    - パス指定なら basename を取り出す
    - 拡張子なしならワイルドカードで補強（例: 'collector' → '*collector*'）
    """
    base = _basename(pat)
    outs = []
    if "." not in base and "*" not in base and "?" not in base:
        outs.append(f"*{base}*")
    else:
        outs.append(base)
    return outs


def _pseudo_path_from_id(nid: str) -> str:
    """
    nodeId を “擬似パス”へゆるく復元:
      - '__' を '/' に
      - '_' を '-' もしくは '_' とみなせるように中庸（後段で正規表現化）
    """
    s = nid
    s = s.replace("__", "/")
    # 残りの '_' はハイフンもあり得るので、そのまま返して後段の regex 側で [-_] として解釈
    return s


def _id_regex_from_pattern(pat: str) -> re.Pattern:
    """
    ID 照合用に、roles パターンから“緩い正規表現”を作る。
    - '/' は '__' 相当とみなし、'__' に置換してからマッチ
    - '_' と '-' は相互置換されている可能性があるので [-_] として扱う
    - '*' は '.*' へ
    """
    p = pat
    # パスセパレータは '__' に寄せる
    p = p.replace("/", "__")
    # 正規表現エスケープ（ワイルドカードは後で戻す）
    esc = re.escape(p)
    esc = esc.replace(r"\*", ".*").replace(r"\?", ".")
    # '-' と '_' のゆらぎ
    esc = esc.replace(r"\-", "[-_]").replace(r"\_", "[-_]")
    return re.compile(esc, re.IGNORECASE)


def match_roles(node_id: str, label: str, role_patterns: List[str]) -> bool:
    """
    照合順:
      1) ラベル（basename グロブ）
      2) ラベル全文への直接グロブ
      3) 擬似パス化した ID に対する緩い正規表現
    どれか当たれば True
    """
    lab = label.lower()
    nid = node_id.lower()

    # 1) ラベル: basename グロブ群
    for pat in role_patterns:
        for g in _label_globs_from_pattern(pat.lower()):
            if fnmatch.fnmatch(lab, g):
                return True

    # 2) ラベル全文にそのままグロブ（roles.yml が basename 以外を書いた場合）
    for pat in role_patterns:
        if fnmatch.fnmatch(lab, pat.lower()):
            return True

    # 3) 擬似パス化 ID に“緩い正規表現”でマッチ
    pseudo = _pseudo_path_from_id(nid)
    for pat in role_patterns:
        rx = _id_regex_from_pattern(pat.lower())
        if rx.search(pseudo):
            return True

    return False


def ensure_styles(styles: Dict[str, str]) -> List[str]:
    out = ["", "%% ---- Auto-generated role styles ----"]
    # spine のデフォルトを補完
    styles = dict(styles or {})
    styles.setdefault("spine", "fill:#111827,stroke:#ef4444,stroke-width:3px,color:#ffffff")
    for cls, style in styles.items():
        out.append(f"classDef {cls} {style};")
    out.append("%% ------------------------------------")
    out.append("")
    return out


def build_stage_subgraphs(
    stage_order: List[str], stage_titles: Dict[str, str], node_classes: Dict[str, Set[str]]
) -> List[str]:
    out: List[str] = ["", "%% ---- Stage subgraphs ----"]
    for st in stage_order or []:
        members = [nid for nid, cls in node_classes.items() if st in cls]
        if not members:
            continue
        title = stage_titles.get(st, st)
        out.append(f'subgraph {st}_cluster["{title}"]')
        out.append("direction TB")
        for nid in sorted(members):
            out.append(f"{nid}")
        out.append("end")
    out.append("%% ---------------------------")
    out.append("")
    return out


def build_loop_arrows(stage_order: List[str]) -> List[str]:
    if not stage_order or len(stage_order) < 2:
        return []
    out = ["", "%% ---- Loop arrows ----"]
    pairs = list(zip(stage_order, stage_order[1:] + stage_order[:1]))
    for a, b in pairs:
        out.append(f"{a}_cluster --> {b}_cluster")
    out.append("%% ----------------------")
    out.append("")
    return out


def build_legend(styles: Dict[str, str], titles: Dict[str, str]) -> List[str]:
    out = ["", "%% ---- Legend (stage → color) ----", "subgraph legend[Legend]", "direction TB"]
    keys = list((styles or {}).keys()) + ["spine"]
    for st in sorted(set(keys)):
        title = titles.get(st, st) if titles else st
        node = f"legend_{st}[{title}]"
        out.append(node)
        out.append(f"class {node} {st};")
    out.append("end")
    out.append("%% ---------------------------------")
    out.append("")
    return out


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--input", required=True)
    ap.add_argument("--roles", required=True)
    ap.add_argument("--manifest", default=None)
    ap.add_argument("--spine-json", default=None)
    ap.add_argument("--output", required=True)
    args = ap.parse_args()

    lines = Path(args.input).read_text(encoding="utf-8").splitlines()
    nodes = parse_nodes(lines)

    roles_cfg = yaml.safe_load(Path(args.roles).read_text(encoding="utf-8")) or {}
    roles: List[dict] = roles_cfg.get("roles", [])
    styles: Dict[str, str] = roles_cfg.get("styles", {}) or {}
    stage_order: List[str] = roles_cfg.get("stages_order", []) or []
    stage_titles: Dict[str, str] = roles_cfg.get("stage_titles", {}) or {}

    manifest = {}
    if args.manifest and Path(args.manifest).exists():
        manifest = yaml.safe_load(Path(args.manifest).read_text(encoding="utf-8")) or {}

    # マッチング
    node_classes: Dict[str, Set[str]] = {}
    for nid, label in nodes.items():
        for r in roles:
            cls = r.get("class_name")
            pats = r.get("patterns", []) or []
            if not cls or not pats:
                continue
            if match_roles(nid, label, pats):
                node_classes.setdefault(nid, set()).add(cls)

    # 明示マニフェスト（優先上書き）
    for stage, files in (manifest.get("assign") or {}).items():
        for want in files or []:
            want_low = want.lower()
            # ラベル照合（basename または完全一致）
            for nid, label in nodes.items():
                lab = label.lower()
                if lab == want_low or lab.endswith("/" + want_low) or lab.endswith(want_low):
                    node_classes.setdefault(nid, set()).add(stage)
                    continue
            # 擬似パス化 ID のゆるい照合
            rx = _id_regex_from_pattern(want_low)
            for nid in nodes.keys():
                if rx.search(_pseudo_path_from_id(nid.lower())):
                    node_classes.setdefault(nid, set()).add(stage)

    # 幹ハイライト
    if args.spine_json and Path(args.spine_json).exists():
        data = json.loads(Path(args.spine_json).read_text(encoding="utf-8"))
        for nid in data.keys():
            if nid in nodes:
                node_classes.setdefault(nid, set()).add("spine")

    out_lines = list(lines)
    out_lines += ensure_styles(styles)
    for nid, cls_set in sorted(node_classes.items()):
        out_lines.append(f"class {nid} {','.join(sorted(cls_set))};")

    if stage_order:
        out_lines += build_stage_subgraphs(stage_order, stage_titles, node_classes)
        out_lines += build_loop_arrows(stage_order)
    out_lines += build_legend(styles, stage_titles)

    Path(args.output).write_text("\n".join(out_lines) + "\n", encoding="utf-8")
    print(f"wrote: {args.output}")


if __name__ == "__main__":
    main()
