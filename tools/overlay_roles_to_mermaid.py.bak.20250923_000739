#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
overlay_roles_to_mermaid.py (v3)
- roles.yml（ステージ定義・色）
- workflow_manifest.yml（明示割当）
- 追加: --spine-json（幹ランキング）を渡すと、上位を class spine で強調
"""

from __future__ import annotations
import argparse
import fnmatch
import re
import json
from pathlib import Path
from typing import Dict, List, Set

import yaml  # 推奨（簡易パーサは省略）

NODE_RE = re.compile(r"^\s*([A-Za-z0-9_./:\-]+)\s*\[(.*?)\]\s*$")


def parse_nodes(lines: List[str]) -> Dict[str, str]:
    nodes: Dict[str, str] = {}
    for ln in lines:
        m = NODE_RE.match(ln)
        if m:
            nodes[m.group(1)] = m.group(2)
    return nodes


def match_roles(node_id: str, label: str, roles: List[dict]) -> Set[str]:
    got: Set[str] = set()
    for r in roles:
        cls = r.get("class_name")
        for pat in r.get("patterns", []):
            if fnmatch.fnmatch(node_id, pat) or fnmatch.fnmatch(label, pat):
                got.add(cls)
                break
    return got


def ensure_styles(styles: Dict[str, str]) -> List[str]:
    out = ["", "%% ---- Auto-generated role styles ----"]
    # spine スタイルが無ければデフォルト付与（太枠＋濃色）
    styles = dict(styles)
    styles.setdefault("spine", "fill:#111827,stroke:#ef4444,stroke-width:3px,color:#ffffff")
    for cls, style in styles.items():
        out.append(f"classDef {cls} {style};")
    out.append("%% ------------------------------------")
    out.append("")
    return out


def build_stage_subgraphs(
    stage_order: List[str], stage_titles: Dict[str, str], node_classes: Dict[str, Set[str]]
) -> List[str]:
    out: List[str] = ["", "%% ---- Stage subgraphs ----"]
    for st in stage_order:
        members = [nid for nid, cls in node_classes.items() if st in cls]
        if not members:
            continue
        title = stage_titles.get(st, st)
        out.append(f'subgraph {st}_cluster["{title}"]')
        out.append("direction TB")
        for nid in sorted(members):
            out.append(f"{nid}")
        out.append("end")
    out.append("%% ---------------------------")
    out.append("")
    return out


def build_loop_arrows(stage_order: List[str]) -> List[str]:
    if len(stage_order) < 2:
        return []
    out = ["", "%% ---- Loop arrows ----"]
    pairs = list(zip(stage_order, stage_order[1:] + stage_order[:1]))
    for a, b in pairs:
        out.append(f"{a}_cluster --> {b}_cluster")
    out.append("%% ----------------------")
    out.append("")
    return out


def build_legend(styles: Dict[str, str], titles: Dict[str, str]) -> List[str]:
    out = ["", "%% ---- Legend (stage → color) ----", "subgraph legend[Legend]", "direction TB"]
    keys = list(styles.keys())
    for st in sorted(keys):
        title = titles.get(st, st)
        node = f"legend_{st}[{title}]"
        out.append(node)
        out.append(f"class {node} {st};")
    out.append("end")
    out.append("%% ---------------------------------")
    out.append("")
    return out


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--input", required=True)
    ap.add_argument("--roles", required=True)
    ap.add_argument("--manifest", default=None)
    ap.add_argument("--spine-json", default=None)  # ★ 追加
    ap.add_argument("--output", required=True)
    args = ap.parse_args()

    lines = Path(args.input).read_text(encoding="utf-8").splitlines()
    nodes = parse_nodes(lines)

    roles_cfg = yaml.safe_load(Path(args.roles).read_text(encoding="utf-8")) or {}
    roles: List[dict] = roles_cfg.get("roles", [])
    styles: Dict[str, str] = roles_cfg.get("styles", {})
    stage_order: List[str] = roles_cfg.get("stages_order", [])
    stage_titles: Dict[str, str] = roles_cfg.get("stage_titles", {})

    manifest = {}
    if args.manifest and Path(args.manifest).exists():
        manifest = yaml.safe_load(Path(args.manifest).read_text(encoding="utf-8")) or {}

    node_classes: Dict[str, Set[str]] = {}
    # 1) 自動割当
    for nid, label in nodes.items():
        cls = match_roles(nid, label, roles)
        if cls:
            node_classes[nid] = cls
    # 2) 明示上書き
    for stage, files in (manifest.get("assign") or {}).items():
        for path in files or []:
            for nid in nodes.keys():
                if nid == path or nid.endswith("/" + path.split("/")[-1]):
                    node_classes.setdefault(nid, set()).add(stage)
    # 3) spine ハイライト
    spine_nodes: Set[str] = set()
    if args.spine_json and Path(args.spine_json).exists():
        data = json.loads(Path(args.spine_json).read_text(encoding="utf-8"))
        spine_nodes = set(data.keys())
        for nid in spine_nodes:
            if nid in nodes:
                node_classes.setdefault(nid, set()).add("spine")

    out_lines = list(lines)
    out_lines += ensure_styles(styles)
    for nid, cls_set in sorted(node_classes.items()):
        out_lines.append(f"class {nid} {','.join(sorted(cls_set))};")

    if stage_order:
        out_lines += build_stage_subgraphs(stage_order, stage_titles, node_classes)
        out_lines += build_loop_arrows(stage_order)
    out_lines += build_legend({**styles, "spine": styles.get("spine", "")}, stage_titles)

    Path(args.output).write_text("\n".join(out_lines) + "\n", encoding="utf-8")
    print(f"wrote: {args.output}")


if __name__ == "__main__":
    main()
