[
  {
    "title": "Add simple alert emitter to observability (stdout/logging)",
    "file": "src/plan_data/observability.py",
    "patch": "--- a/src/plan_data/observability.py\n+++ b/src/plan_data/observability.py\n@@\n+import json as _json\n+import logging as _logging\n+import os as _os\n+import sys as _sys\n+\n+# 既存: NOCTRIA_OBS_MODE=stdout|off|db|auto の切替がある想定\n+# ここに“どこからでも使える”軽量発火APIを追加。\n+\n+def emit_alert(kind: str, message: str = \"\", **fields):\n+    \"\"\"最小コストのアラート発火。\n+    - stdout: 1行JSONで出力（testsのcapture_alertsで拾える）\n+    - その他: logging.WARNING でも出す（保険）\n+    \"\"\"\n+    try:\n+        payload = {\"kind\": kind, \"message\": message or \"\", **fields}\n+        mode = (_os.getenv(\"NOCTRIA_OBS_MODE\") or \"auto\").lower()\n+\n+        line = _json.dumps(payload, ensure_ascii=False)\n+        if mode in (\"stdout\", \"auto\"):  # auto で DSN無→stdout という既存方針に整合\n+            print(line)\n+            _sys.stdout.flush()\n+        # どのモードでもWARNINGログに残す（テスト・運用の安全網）\n+        _logging.getLogger(\"noctria.alert\").warning(line)\n+    except Exception as e:  # 失敗してもアプリを止めない\n+        _logging.getLogger(\"noctria.alert\").warning(f\"emit_alert_failed: {e}\")\n"
  },
  {
    "title": "QUALITY gate: emit alerts on missing_ratio / data_lag",
    "file": "src/plan_data/quality_gate.py",
    "patch": "--- a/src/plan_data/quality_gate.py\n+++ b/src/plan_data/quality_gate.py\n@@\n from __future__ import annotations\n@@\n+from plan_data.observability import emit_alert\n@@\n-def evaluate_quality(fb, conn_str=None):\n+def evaluate_quality(fb, conn_str=None):\n     \"\"\"\n     FeatureBundle から品質を評価して Result を返す。\n     期待属性:\n       - fb.context[\"missing_ratio\"] (0.0~1.0)\n       - fb.context[\"data_lag_min\"] (int)\n       - fb.context[\"symbol\"], fb.context[\"timeframe\"], 任意で fb.context[\"trace\"]\n     \"\"\"\n     ctx = getattr(fb, \"context\", {}) or {}\n     miss = float(ctx.get(\"missing_ratio\", 0.0))\n     lag  = int(ctx.get(\"data_lag_min\", 0))\n     sym  = ctx.get(\"symbol\")\n     tf   = ctx.get(\"timeframe\")\n     trace= ctx.get(\"trace\")\n@@\n-    # しきい値判定（例: 欠損>10% か遅延>30分でNG）\n-    ok = not (miss >= 0.10 or lag >= 30)\n+    # しきい値判定（例: 欠損>10% か遅延>30分でNG）\n+    ok = not (miss >= 0.10 or lag >= 30)\n     action = \"SCALE\" if miss >= 0.10 else (\"FLAT\" if lag >= 30 else \"HOLD\")\n@@\n-    res = QualityResult(ok=ok, action=action, missing_ratio=miss, data_lag_min=lag)\n+    res = QualityResult(ok=ok, action=action, missing_ratio=miss, data_lag_min=lag)\n+\n+    # 🔔 期待されるQUALITYアラートを発火\n+    if miss >= 0.10:\n+        emit_alert(\n+            \"QUALITY.MISSING_RATIO\",\n+            message=f\"missing_ratio={miss:.2%}\",\n+            symbol=sym, timeframe=tf, trace=trace, missing_ratio=miss\n+        )\n+    if lag >= 30:\n+        emit_alert(\n+            \"QUALITY.DATA_LAG\",\n+            message=f\"data_lag_min={lag}\",\n+            symbol=sym, timeframe=tf, trace=trace, data_lag_min=lag\n+        )\n     return res\n"
  },
  {
    "title": "NOCTUS gate: emit alert when strategy is blocked",
    "file": "src/noctria/noctus_gate.py",
    "patch": "--- a/src/noctria/noctus_gate.py\n+++ b/src/noctria/noctus_gate.py\n@@\n from __future__ import annotations\n@@\n+from plan_data.observability import emit_alert\n@@\n-def run_strategy_and_decide(strategy, fb, conn_str=None):\n+def run_strategy_and_decide(strategy, fb, conn_str=None):\n     \"\"\"戦略を実行し、NoctusGate でブロック判定する。\"\"\"\n     decision = strategy.run(fb)\n@@\n-    if should_block(decision):\n+    if should_block(decision):\n         decision = {\"decision\": {\"decision\": {\"action\": \"REJECT\"}}}\n+        ctx = getattr(fb, \"context\", {}) or {}\n+        emit_alert(\n+            \"NOCTUS.BLOCKED\",\n+            message=\"blocked by NoctusGate\",\n+            **{k: ctx.get(k) for k in (\"symbol\", \"timeframe\", \"trace\") if k in ctx}\n+        )\n     return decision\n"
  }
]
