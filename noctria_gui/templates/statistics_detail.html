{% extends "base.html" %}
{% block title %}📊 詳細分析 - Noctria Kingdom{% endblock %}

{% block content %}
<h2>📊 詳細分析（{{ mode }}: {{ key }}）</h2>

<!-- 📌 再評価ボタン（戦略モード限定） -->
{% if mode == "strategy" %}
<form method="post" action="/pdca/recheck" style="margin-bottom: 1rem;">
  <input type="hidden" name="strategy_name" value="{{ key }}">
  <button class="button">📌 この戦略を再評価</button>
</form>
{% endif %}

<!-- 🔍 ソート設定 -->
<form method="get" action="/statistics/detail" style="margin-bottom: 1rem;">
  <input type="hidden" name="mode" value="{{ mode }}">
  <input type="hidden" name="key" value="{{ key }}">

  <label>ソート項目:</label>
  <select name="sort_by">
    <option value="date" {% if sort_by == "date" %}selected{% endif %}>📅 日付</option>
    <option value="win_rate" {% if sort_by == "win_rate" %}selected{% endif %}>📈 勝率</option>
    <option value="max_drawdown" {% if sort_by == "max_drawdown" %}selected{% endif %}>📉 最大DD</option>
  </select>

  <label style="margin-left: 1rem;">順序:</label>
  <select name="order">
    <option value="asc" {% if order == "asc" %}selected{% endif %}>昇順</option>
    <option value="desc" {% if order == "desc" %}selected{% endif %}>降順</option>
  </select>

  <button type="submit" class="button">🔄 並び替え</button>
</form>

<!-- 📄 CSV出力 -->
<a class="button" href="/statistics/detail/export?mode={{ mode }}&key={{ key }}&sort_by={{ sort_by }}&order={{ order }}">📄 CSVエクスポート</a>

<!-- 📊 表 -->
<table style="margin-top: 1rem;">
  <thead>
    <tr>
      <th>日付</th>
      <th>勝率（%）</th>
      <th>最大DD（%）</th>
    </tr>
  </thead>
  <tbody>
    {% for row in results %}
    <tr>
      <td>{{ row.date }}</td>
      <td>{{ row.win_rate }}</td>
      <td>{{ row.max_drawdown }}</td>
    </tr>
    {% endfor %}
  </tbody>
</table>

<!-- 📘 統計サマリ表示 -->
<h3 style="margin-top: 2rem;">📘 指標の統計サマリ</h3>
<table style="margin-bottom: 2rem;">
  <thead>
    <tr>
      <th>指標</th>
      <th>件数</th>
      <th>最小</th>
      <th>Q1</th>
      <th>中央値</th>
      <th>Q3</th>
      <th>最大</th>
    </tr>
  </thead>
  <tbody id="statSummary">
    <!-- JSで挿入 -->
  </tbody>
</table>

<!-- 📈 折れ線グラフ -->
<h3>📈 勝率・最大DDの時系列推移</h3>
<canvas id="lineChart" height="100"></canvas>

<!-- 📊 ヒストグラム -->
<h3 style="margin-top: 2rem;">📊 ヒストグラム</h3>
<canvas id="winHistogram" height="100"></canvas>
<canvas id="ddHistogram" height="100"></canvas>

<!-- 🔢 Bin数セレクト -->
<div style="margin-top: 1rem;">
  <label>Bin数:</label>
  <select id="binCountSelect">
    <option value="5">5</option>
    <option value="10" selected>10</option>
    <option value="15">15</option>
    <option value="20">20</option>
  </select>
</div>

<!-- 💾 保存ボタン -->
<div style="margin-top: 1rem;">
  <button class="button" onclick="downloadChart('winHistogram', 'win_histogram.png')">💾 勝率ヒストグラム保存</button>
  <button class="button" onclick="downloadChart('ddHistogram', 'dd_histogram.png')">💾 最大DDヒストグラム保存</button>
  <button class="button" onclick="downloadChart('lineChart', 'time_series_chart.png')">💾 時系列グラフ保存</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  const rawData = {{ results | tojson }};
  let winChart, ddChart, lineChart;

  const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  const chartColors = {
    text: isDark ? "#ccc" : "#222",
    grid: isDark ? "#444" : "#ccc",
    win: "rgba(54, 162, 235, 0.7)",
    dd: "rgba(255, 99, 132, 0.7)"
  };

  function computeStats(values) {
    const sorted = values.filter(v => typeof v === 'number' && !isNaN(v)).sort((a, b) => a - b);
    const n = sorted.length;
    if (n === 0) return null;
    const q1 = sorted[Math.floor(n * 0.25)];
    const q2 = sorted[Math.floor(n * 0.5)];
    const q3 = sorted[Math.floor(n * 0.75)];
    return {
      count: n, min: sorted[0], q1: q1, median: q2, q3: q3, max: sorted[n - 1]
    };
  }

  function renderSummary() {
    const winStats = computeStats(rawData.map(r => Number(r.win_rate)));
    const ddStats = computeStats(rawData.map(r => Number(r.max_drawdown)));
    const tbody = document.getElementById("statSummary");
    tbody.innerHTML = "";

    function rowHTML(label, stats) {
      if (!stats) return `<tr><td>${label}</td><td colspan="6">データなし</td></tr>`;
      return `<tr><td>${label}</td><td>${stats.count}</td><td>${stats.min}</td><td>${stats.q1}</td><td>${stats.median}</td><td>${stats.q3}</td><td>${stats.max}</td></tr>`;
    }

    tbody.innerHTML += rowHTML("勝率（%）", winStats);
    tbody.innerHTML += rowHTML("最大DD（%）", ddStats);
  }

  function drawLineChart() {
    const labels = rawData.map(r => r.date);
    const winData = rawData.map(r => Number(r.win_rate));
    const ddData = rawData.map(r => Number(r.max_drawdown));
    const ctx = document.getElementById("lineChart").getContext("2d");
    if (lineChart) lineChart.destroy();
    lineChart = new Chart(ctx, {
      type: "line",
      data: {
        labels: labels,
        datasets: [
          { label: "勝率", data: winData, borderColor: chartColors.win, backgroundColor: chartColors.win, tension: 0.3, yAxisID: "y1" },
          { label: "最大DD", data: ddData, borderColor: chartColors.dd, backgroundColor: chartColors.dd, tension: 0.3, yAxisID: "y2" }
        ]
      },
      options: {
        responsive: true,
        plugins: { legend: { position: "top" }},
        scales: {
          y1: { type: "linear", position: "left", beginAtZero: true, title: { display: true, text: "勝率", color: chartColors.text }, ticks: { color: chartColors.text }, grid: { color: chartColors.grid }},
          y2: { type: "linear", position: "right", beginAtZero: true, title: { display: true, text: "最大DD", color: chartColors.text }, ticks: { color: chartColors.text }, grid: { drawOnChartArea: false }},
          x: { ticks: { color: chartColors.text }, grid: { color: chartColors.grid } }
        }
      }
    });
  }

  function renderHistogram(values, canvasId, label, color, binCount = 10) {
    const filtered = values.filter(v => typeof v === 'number' && !isNaN(v));
    const min = Math.min(...filtered), max = Math.max(...filtered);
    const step = (max - min) / binCount || 1;
    const bins = Array(binCount).fill(0), labels = [];

    for (let i = 0; i < binCount; i++) {
      const start = min + step * i, end = start + step;
      labels.push(`${start.toFixed(1)}〜${end.toFixed(1)}`);
    }
    filtered.forEach(v => {
      const idx = Math.min(Math.floor((v - min) / step), binCount - 1);
      bins[idx]++;
    });

    const ctx = document.getElementById(canvasId).getContext("2d");
    if (canvasId === "winHistogram" && winChart) winChart.destroy();
    if (canvasId === "ddHistogram" && ddChart) ddChart.destroy();

    const chart = new Chart(ctx, {
      type: "bar",
      data: {
        labels: labels,
        datasets: [{ label: label, data: bins, backgroundColor: color }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false }},
        scales: {
          y: { beginAtZero: true, ticks: { stepSize: 1, precision: 0, color: chartColors.text }, grid: { color: chartColors.grid }},
          x: { ticks: { color: chartColors.text }, grid: { color: chartColors.grid }}
        }
      }
    });

    if (canvasId === "winHistogram") winChart = chart;
    if (canvasId === "ddHistogram") ddChart = chart;
  }

  function drawAllHistograms() {
    const binCount = parseInt(document.getElementById("binCountSelect").value);
    const winRates = rawData.map(r => Number(r.win_rate));
    const drawdowns = rawData.map(r => Number(r.max_drawdown));
    renderHistogram(winRates, "winHistogram", "勝率分布", chartColors.win, binCount);
    renderHistogram(drawdowns, "ddHistogram", "最大DD分布", chartColors.dd, binCount);
  }

  function downloadChart(canvasId, filename) {
    const canvas = document.getElementById(canvasId);
    const link = document.createElement("a");
    link.href = canvas.toDataURL("image/png", 1.0);
    link.download = filename;
    link.click();
  }

  renderSummary();
  drawLineChart();
  drawAllHistograms();
  document.getElementById("binCountSelect").addEventListener("change", drawAllHistograms);
</script>
{% endblock %}
