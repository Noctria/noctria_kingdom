<script>
const metricsDict = {{ metrics_dict | tojson | safe }};
const overallMetrics = {{ overall_metrics | tojson | safe }};
const dashboardMetrics = {{ dashboard_metrics | tojson | safe }};
const aiNames = {{ ai_names | tojson | safe }};
const aiMetricDist = {{ ai_metric_dist | tojson | safe }};
let selectedMetric = dashboardMetrics[0].key;
let selectedAI = aiNames[0];
let selectedMode = "trend"; // or "dist"

window.drawMetricChart = function(metric, ai) {
  const ctx = document.getElementById('metricChart').getContext('2d');
  if (window.metricChartObj) window.metricChartObj.destroy();
  let data, label, unit, dec;
  let showAI = true;
  if (ai === 'overall') {
    data = overallMetrics[metric];
    label = "全体平均";
    showAI = false;
  } else {
    data = (metricsDict[metric] && metricsDict[metric][ai]) ? metricsDict[metric][ai] : null;
    label = ai;
  }
  let conf = dashboardMetrics.find(m => m.key === metric);
  unit = conf.unit;
  dec = conf.dec;
  window.metricChartObj = new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.labels,
      datasets: [{
        label: conf.label + (showAI ? `（${label}）` : "（全体平均）"),
        data: data.values,
        borderColor: '#18e1ef',
        backgroundColor: 'rgba(24,225,239,0.10)',
        pointRadius: 3,
        tension: 0.20,
        fill: false
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { labels: { color: "#e6f1ff" } },
        title: { display: true, text: `${conf.label}トレンド（${label}）`, color: "#e6f1ff" }
      },
      scales: {
        x: { ticks: { color: "#a8b2d1" } },
        y: { ticks: { color: "#a8b2d1" } }
      }
    }
  });
  // Summary update
  document.getElementById('metric-summary-label').textContent = conf.label;
  document.getElementById('metric-avg').textContent = (data.avg != null) ? data.avg : "-";
  document.getElementById('metric-max').textContent = (data.max != null) ? data.max : "-";
  document.getElementById('metric-min').textContent = (data.min != null) ? data.min : "-";
  document.getElementById('metric-diff').textContent = (data.diff != null ? (data.diff >= 0 ? "+" : "") + data.diff : "-");
  document.getElementById('metric-unit').textContent = unit;
  document.getElementById('metric-unit-max').textContent = unit;
  document.getElementById('metric-unit-min').textContent = unit;
  document.getElementById('metric-unit-diff').textContent = unit;
  // AI switcher visibility
  document.getElementById('ai-switcher').style.display = showAI ? 'flex' : 'none';
  // Overall tab active toggle
  document.getElementById('tab-overall').classList.toggle('active', !showAI);
  // AI tab active toggle
  if (showAI) {
    document.querySelectorAll('.ai-tab').forEach(btn => btn.classList.remove('active'));
    const aiBtn = Array.from(document.querySelectorAll('.ai-tab')).find(btn => btn.getAttribute('onclick').includes(`'${ai}'`));
    if (aiBtn) aiBtn.classList.add('active');
  }
}

window.drawDistCharts = function(metric, ai) {
  const histCtx = document.getElementById('distHistogram').getContext('2d');
  const boxCtx = document.getElementById('distBoxplot').getContext('2d');
  if (window.histChart) window.histChart.destroy();
  if (window.boxChart) window.boxChart.destroy();

  let data = [];
  if (ai === 'overall') {
    data = aiMetricDist[metric]?.flatMap(d => d.values) || [];
  } else {
    data = aiMetricDist[metric]?.find(d => d.ai === ai)?.values || [];
  }

  window.histChart = new Chart(histCtx, {
    type: 'histogram',
    data: {
      datasets: [{
        label: metric,
        data: data
      }]
    },
    options: {
      responsive: true,
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks: { color: "#a8b2d1" } },
        y: { ticks: { color: "#a8b2d1" } }
      }
    }
  });

  window.boxChart = new Chart(boxCtx, {
    type: 'boxplot',
    data: {
      labels: [metric],
      datasets: [{
        label: metric,
        data: [data]
      }]
    },
    options: {
      responsive: true,
      plugins: { legend: { display: false } },
      scales: {
        y: { ticks: { color: "#a8b2d1" } }
      }
    }
  });
}

window.switchMetric = function(metric) {
  selectedMetric = metric;
  if (selectedMode === "trend") {
    window.drawMetricChart(selectedMetric, selectedAI);
  } else {
    window.drawDistCharts(selectedMetric, selectedAI);
  }
}

window.switchAI = function(ai) {
  selectedAI = ai;
  if (selectedMode === "trend") {
    window.drawMetricChart(selectedMetric, selectedAI);
  } else {
    window.drawDistCharts(selectedMetric, selectedAI);
  }
}

window.switchChartMode = function(mode) {
  selectedMode = mode;
  document.getElementById('trend-canvas-box').style.display = (mode === "trend") ? 'block' : 'none';
  document.getElementById('dist-canvas-box').style.display = (mode === "dist") ? 'block' : 'none';
  if (mode === "trend") {
    window.drawMetricChart(selectedMetric, selectedAI);
  } else {
    window.drawDistCharts(selectedMetric, selectedAI);
  }
}

// 初期表示
window.drawMetricChart(selectedMetric, selectedAI);
</script>
<style>
/* HUDスタイルUIのボタン・タブ類 */
.ai-tab .ai-detail-link {
  margin-left: 0.3em;
  vertical-align: middle;
  color: #19c0e9;
}
</style>
{% endblock %}
