name: Merge Guard (labels)

on:
  pull_request:
    types: [opened, reopened, synchronize]
  workflow_run:
    workflows:
      - Backtest on Adopt PR (self-hosted)
      - Codex Quality Gate
      - noctria_policy_check
    types: [completed]

permissions:
  contents: read
  pull-requests: write
  checks: read
  actions: read

concurrency:
  group: merge-guard-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  # PR„ÅåÈñã„Åã„Çå„Åü„Çâ„ÄÅ„Åæ„Åö„ÅØ do-not-merge „Çí‰ªò„Åë„Çã
  init-label:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Ensure labels & apply block
        uses: actions/github-script@v7
        env:
          BLOCK_LABEL: do-not-merge
          READY_LABEL: ready-to-merge
          REQUIRED: |
            Backtest on Adopt PR (self-hosted)
            Codex Quality Gate
            noctria_policy_check
        with:
          script: |
            const {owner, repo} = context.repo;
            async function ensureLabel(name, color, description) {
              try {
                await github.rest.issues.getLabel({owner, repo, name});
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({owner, repo, name, color, description});
                } else { throw e; }
              }
            }
            await ensureLabel(process.env.BLOCK_LABEL, 'd73a4a', 'Do not merge until required checks pass');
            await ensureLabel(process.env.READY_LABEL, '0e8a16', 'All required checks passed');

            const number = context.payload.pull_request.number;
            await github.rest.issues.addLabels({
              owner, repo, issue_number: number, labels: [process.env.BLOCK_LABEL]
            });

            const required = process.env.REQUIRED.trim().split('\n').map(s=>s.trim()).filter(Boolean);
            const body = [
              `üîí Applied \`${process.env.BLOCK_LABEL}\` while checks run.`,
              `Required workflows:`, ...required.map(n=>`- ${n}`)
            ].join('\n');
            await github.rest.issues.createComment({owner, repo, issue_number: number, body});

  # ÂøÖÈ†à„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÅåÂÆå‰∫Ü„Åô„Çã„Åü„Å≥„Å´„ÄÅPR„ÅÆ„É©„Éô„É´„ÇíÂÜçË©ï‰æ°
  reconcile:
    if: github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    steps:
      - name: Reconcile labels based on required workflows
        uses: actions/github-script@v7
        env:
          BLOCK_LABEL: do-not-merge
          READY_LABEL: ready-to-merge
          REQUIRED: |
            Backtest on Adopt PR (self-hosted)
            Codex Quality Gate
            noctria_policy_check
        with:
          script: |
            const {owner, repo} = context.repo;
            const required = process.env.REQUIRED.trim().split('\n').map(s=>s.trim()).filter(Boolean);
            const wr = context.payload.workflow_run;

            if (!wr.pull_requests || wr.pull_requests.length === 0) {
              core.info('No associated PRs. Nothing to do.');
              return;
            }

            for (const prRef of wr.pull_requests) {
              const number = prRef.number;
              const pr = await github.rest.pulls.get({owner, repo, pull_number: number});
              const headSha = pr.data.head.sha;

              // headSha„Å´Á¥ê„Å•„Åè pull_request „Ç§„Éô„É≥„Éà„ÅÆworkflow run„ÇíÂèéÈõÜ
              const runs = await github.paginate(
                github.rest.actions.listWorkflowRunsForRepo,
                {owner, repo, event: 'pull_request', per_page: 100, head_sha: headSha}
              );

              const statusByName = Object.fromEntries(required.map(n => [n, 'missing']));
              for (const run of runs) {
                if (required.includes(run.name) && run.head_sha === headSha && run.status === 'completed') {
                  statusByName[run.name] = run.conclusion || 'unknown';
                }
              }

              const allOk = required.every(n => statusByName[n] === 'success');

              const currentLabels = (await github.rest.issues.listLabelsOnIssue({
                owner, repo, issue_number: number
              })).data.map(l => l.name);

              async function add(name){
                if(!currentLabels.includes(name)){
                  await github.rest.issues.addLabels({owner, repo, issue_number: number, labels:[name]});
                  currentLabels.push(name);
                }
              }
              async function remove(name){
                if(currentLabels.includes(name)){
                  await github.rest.issues.removeLabel({owner, repo, issue_number: number, name}).catch(()=>{});
                }
              }

              if (allOk) {
                await remove(process.env.BLOCK_LABEL);
                await add(process.env.READY_LABEL);
                await github.rest.issues.createComment({
                  owner, repo, issue_number: number,
                  body: `‚úÖ All required workflows passed for \`${pr.data.head.ref}\` @ ${headSha.slice(0,7)}. Removing \`${process.env.BLOCK_LABEL}\`, adding \`${process.env.READY_LABEL}\`.`
                });
              } else {
                await add(process.env.BLOCK_LABEL);
                await remove(process.env.READY_LABEL);
                const pending = Object.entries(statusByName)
                  .filter(([_, s]) => s !== 'success')
                  .map(([n, s]) => `- ${n}: **${s}**`)
                  .join('\n');
                await github.rest.issues.createComment({
                  owner, repo, issue_number: number,
                  body: `‚è≥ Waiting for required workflows on \`${pr.data.head.ref}\` @ ${headSha.slice(0,7)}:\n${pending}`
                });
              }
            }
